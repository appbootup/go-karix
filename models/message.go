// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"
	"github.com/shopspring/decimal"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Message message
// swagger:model Message
type Message struct {

	// Unique ID of Account which created this message
	AccountUID string `json:"account_uid,omitempty"`

	// Destination number for the message in E.164 format
	Destination string `json:"destination,omitempty"`

	// Direction of the message.
	// - inbound: Message was sent to a number owned by the karix account
	// - outbound: Message was sent to a destination using karix account
	//
	// Enum: [inbound outbound]
	Direction string `json:"direction,omitempty"`

	// error
	Error *MessageError `json:"error,omitempty"`

	// message type
	MessageType string `json:"message_type,omitempty"`

	// Mobile Country Code of the destination number.
	// Refer to [Wikipedia: Mobile country code](https://en.wikipedia.org/wiki/Mobile_country_code)
	//
	MobileCountryCode string `json:"mobile_country_code,omitempty"`

	// Mobile Network Code of the destination number.
	// Refer to [Wikipedia: Mobile country code](https://en.wikipedia.org/wiki/Mobile_country_code)
	//
	MobileNetworkCode string `json:"mobile_network_code,omitempty"`

	// Number of parts to the message if the message was too long
	// Refer to [`text`](#/definitions/Message/properties/text)
	//
	Parts int64 `json:"parts,omitempty"`

	// The timestamp when message was accepted and queued in Karix system
	// Format: date-time
	QueuedTime strfmt.DateTime `json:"queued_time,omitempty"`

	// Cost per part of this message.
	// Refer to [`text`](#/definitions/Message/properties/text)
	//
	Rate decimal.Decimal `json:"rate,omitempty"`

	// In case we are unable to send the message to destination after queueing
	// we will refund the `total_cost` you were charged.
	// `null` if there was no refund.
	//
	Refund decimal.NullDecimal `json:"refund,omitempty"`

	// The timestamp when the message was processed and sent to destination
	// Format: date-time
	SentTime *strfmt.DateTime `json:"sent_time,omitempty"`

	// Sender ID for the message
	Source string `json:"source,omitempty"`

	// Current status of the message. Possible values:
	// - `queued`: Message has been queued in Karix system
	//             (for either `inbound` or `outbound` direction)
	// - `sent`: The `outbound` message has been sent to carriers for delivery
	// - `failed`: In case of `outbound` message, this means that Karix failed
	//             to send the message to a carrier.
	//             In case of `inbound` message, this means that Karix failed
	//             to send the message to its webhook, if configured.
	// - `delivered`: The `outbound` message was delivered to its receiver.
	// - `undelivered`: The `outbound` message falied to be delivered to its receiver.
	// - `rejected`: The `outbound` message was rejected by the chosen carrier.
	//
	// Enum: [queued sent failed delivered undelivered rejected]
	Status string `json:"status,omitempty"`

	// Text of the message to be sent.
	// - Message can contain non-GSM and unicode characters
	// - A GSM only message with more than 160 characters will be automatically broken
	//   into parts each of length 153 for billing purposes
	// - A Non-GSM (and unicode) message with more than 70 characters will be automatically
	//   broken into parts each of length 67 for billing purposes
	//
	Text string `json:"text,omitempty"`

	// Total cost for this message including all parts.
	// Refer to [`text`](#/definitions/Message/properties/text)
	//
	TotalCost decimal.Decimal `json:"total_cost,omitempty"`

	// Unique ID for a message sent or received
	UID string `json:"uid,omitempty"`

	// The timestamp when the status of message was last updated.
	// - If the current status is `delivered` then this timestamp also represents
	//   delivered time
	// - If the current status is `undelivered` then this timestamp also represents
	//   undelivered time
	//
	// Format: date-time
	UpdatedTime *strfmt.DateTime `json:"updated_time,omitempty"`
}

// Validate validates this message
func (m *Message) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueuedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSentTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var messageTypeDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["inbound","outbound"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageTypeDirectionPropEnum = append(messageTypeDirectionPropEnum, v)
	}
}

const (

	// MessageDirectionInbound captures enum value "inbound"
	MessageDirectionInbound string = "inbound"

	// MessageDirectionOutbound captures enum value "outbound"
	MessageDirectionOutbound string = "outbound"
)

// prop value enum
func (m *Message) validateDirectionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageTypeDirectionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Message) validateDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.Direction) { // not required
		return nil
	}

	// value enum
	if err := m.validateDirectionEnum("direction", "body", m.Direction); err != nil {
		return err
	}

	return nil
}

func (m *Message) validateError(formats strfmt.Registry) error {

	if swag.IsZero(m.Error) { // not required
		return nil
	}

	if m.Error != nil {
		if err := m.Error.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("error")
			}
			return err
		}
	}

	return nil
}

func (m *Message) validateQueuedTime(formats strfmt.Registry) error {

	if swag.IsZero(m.QueuedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("queued_time", "body", "date-time", m.QueuedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Message) validateSentTime(formats strfmt.Registry) error {

	if swag.IsZero(m.SentTime) { // not required
		return nil
	}

	if err := validate.FormatOf("sent_time", "body", "date-time", m.SentTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var messageTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["queued","sent","failed","delivered","undelivered","rejected"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messageTypeStatusPropEnum = append(messageTypeStatusPropEnum, v)
	}
}

const (

	// MessageStatusQueued captures enum value "queued"
	MessageStatusQueued string = "queued"

	// MessageStatusSent captures enum value "sent"
	MessageStatusSent string = "sent"

	// MessageStatusFailed captures enum value "failed"
	MessageStatusFailed string = "failed"

	// MessageStatusDelivered captures enum value "delivered"
	MessageStatusDelivered string = "delivered"

	// MessageStatusUndelivered captures enum value "undelivered"
	MessageStatusUndelivered string = "undelivered"

	// MessageStatusRejected captures enum value "rejected"
	MessageStatusRejected string = "rejected"
)

// prop value enum
func (m *Message) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, messageTypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Message) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *Message) validateUpdatedTime(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_time", "body", "date-time", m.UpdatedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Message) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Message) UnmarshalBinary(b []byte) error {
	var res Message
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MessageError In case of a failure to send a message this will tell you the
// reason of the failure.
//
// swagger:model MessageError
type MessageError struct {

	// Error Code
	Code string `json:"code,omitempty"`

	// Error Message
	Message string `json:"message,omitempty"`
}

// Validate validates this message error
func (m *MessageError) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MessageError) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MessageError) UnmarshalBinary(b []byte) error {
	var res MessageError
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
